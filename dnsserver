#!/usr/bin/env python3
from argparse import ArgumentParser
import binascii
import threading
import endpoints
from socket import socket, AF_INET, SOCK_DGRAM
import dnslib
import zlib

# parse arguments and store them accordingly
parser = ArgumentParser(
    prog="deployCDN", description="deploy necessary resources to set up a CDN"
)
parser.add_argument("-p", dest="port")
parser.add_argument("-o", dest="origin")
parser.add_argument("-n", dest="name")
parser.add_argument("-u", dest="username")
parser.add_argument("-i", dest="keyfile")

args = parser.parse_args()

if args.port is None:
    raise ValueError("No value for port supplied")
if args.origin is None:
    raise ValueError("No value for origin supplied")
if args.name is None:
    raise ValueError("No value for name supplied")
if args.username is None:
    raise ValueError("No value for username supplied")
if args.keyfile is None:
    raise ValueError("No value for keyfile supplied")

PORT = args.port
ORIGIN = args.origin
NAME = args.name
USERNAME = args.username
KEYFILE = args.keyfile

# set up server socket
sock = socket(AF_INET, SOCK_DGRAM)
sock.connect(("10.0.0.0", 0))
IP = sock.getsockname()[0]
sock.close()

dns_sock = socket(AF_INET, SOCK_DGRAM)
dns_sock.bind((IP, PORT))


def respond_to_request(message):
    packet = binascii.unhexlify(message)
    decoded = dnslib.DNSRecord.parse(packet)
    return message


# start thread that continually updates http server availability


# listen to incoming requests forever
while True:
    message = dns_sock.recvfrom(50000)
    threading.Thread(target=respond_to_request, args=[message])
